// le module permet de precompiler des templates et de les mettre en cache jusqu'à l'arrêt du serveur
// TODO mettre une durée de vie avant recreation forcée des fichiers mis en cache
"use strict";

var u = require("underscore"),
path = require("path"),
url = require("url"),
fs = require("fs");

function TemplateSystem (paramsTemplate){
	// nb de Mo en cache. Si valeur negative, pas de limite
	this.limitCache = 0;
	this.dossierCacheROM = "_cache";
	this.dossierViews = "views";
	this.cache = {tpl:[], size:0};
	fs.mkdir (this.dossierCacheROM);
	// TODO penser à mettre en fermeture de serveur la commande fs.rmdir ();
	if(typeof paramsTemplate == "object") {
		if(typeof paramsTemplate.limitCache == "number") {
			this.limitCache = paramsTemplate.limitCache;
		}
	}
}

TemplateSystem.prototype = {
	// fonction privée appelée dans get
	Create : function(pathTemplate, params, callbackSuccess, noCache) {
		var self = this;
		fs.open(this.dossierViews + "/" + pathTemplate, "r", function(err, fd) {
			if (err) {
				console.log ("ERREUR : n°" + err.errno + ":" + err.code + " path : " + err.path);
				// TODO envoyer exception à log avec err.errno, err.code et err.path
				return;
			}
			fs.fstat(fd, function(err, stats) {
				var bufferSize=stats.size,
					buffer=new Buffer(bufferSize);

				fs.read(fd, buffer, 0, bufferSize, 0, function (err, bytesRead, bufferRead){
					var content = u.template (bufferRead.toString('utf8', 0, bytesRead), params);
					if (!noCache) {
						// dispatch event sur UpdateCache avec le template en paramètre
						self.UpdateCache (pathTemplate, content, content.length);
					}

					fs.open (self.dossierCacheROM + "/" + pathTemplate, "w+", function (err, fdCache){
						if (err) {
							// TODO envoyer exception à log avec err.errno, err.code et err.path
							return;
						}
						fs.write (fdCache, new Buffer (content, content.length), 0, content.length, 0, function (err, written, buffer){
							if (err) {
								console.log ("ERREUR : n°" + err.errno + ":" + err.code + " path : " + err.path);
								// TODO envoyer exception à log avec err.errno, err.code et err.path
								return;
							}
							self.cache.tpl[pathTemplate].file = {pt : fdCache, size : written};
						});
					});
					
					callbackSuccess (content);
				});
			});
			//fs.close(fd); TODO fermer tous les fichiers avant de supprimer le dossier à la fin de vie du serveur
		});		
	},
	
	// fonction renvoyant le template désiré
	Get : function(pathTemplate, params, callbackSuccess, noCache) {
		// verifie l'existance de template dans le cache
		var cacheTmpl = this.cache.tpl[pathTemplate];
		if(cacheTmpl) {
			// si present alors incremente compteur utilisation du template
			cacheTmpl.use++;
			// si cache en RAM
			if(cacheTmpl.content && cacheTmpl.content != "") {
				var generateContent = cacheTmpl.content;
				// renvoie le template en asynchrone
				process.nextTick (function() {
					callbackSuccess (generateContent);
				});
			}
			// sinon récupération du cache dans le fichier
			else {
				// si la creation a été demandée par un autre utilisateur et est en cours
				if (!cacheTmpl.file) {
					if (!cacheTmpl.pileWait) {
						cacheTmpl.pileWait = [];
					}
					cacheTmpl.pileWait.push (callbackSuccess);
				}
				else {
					fs.read (cacheTmpl.file.pt, new Buffer(cacheTmpl.file.size), 0, cacheTmpl.file.size, 0, function (err, bytesRead, buffer) {
						if (err) {
							console.log ("ERREUR : n°" + err.errno + " code : " + err.code + " path : " + err.path);
							// TODO envoyer exception à log avec err.errno, err.code et err.path
							return;
						}
						callbackSuccess (buffer.toString('utf8', 0, bytesRead));
					});
				}
			}
		}
		else {
			// permet de savoir que la ressource est en cours de création si conccurence de demandes par les utilisateurs
			this.cache.tpl[pathTemplate] = {};
			// crée le template
			this.Create (pathTemplate, params, callbackSuccess, noCache);
		}
	},
	
	// ajoute dans le cache
	AddToCache : function(pathTemplate, buffer, bufferSize) {
		var self = this;
		this.cache.size += bufferSize;
		var tmp = this.cache.tpl[pathTemplate];
		if (tmp.pileWait) {
			for (var i = 0, nbWaiting = tmp.pileWait.length; i < nbWaiting; i++) {
				tmp.pileWait[i](buffer);
			}
			// on nettoie juste, histoire de pas trop faire desordre
			delete tmp.pileWait;
		}
		this.cache.tpl[pathTemplate] = {
			content : buffer,
			size : bufferSize,
			use : 1
		};
		//console.log ("add to cache : " + this.cache.tpl[pathTemplate]);
	},
	
	// met à jour le cache
	UpdateCache : function(pathTemplate, buffer, bufferSize) {
		var self = this;
		// si cache plein alors vide le moins utilisé
		if(this.limitCache > 0) {
			process.nextTick (function() {
				if(self.cache.size + bufferSize > self.limitCache * 1000 * 1000) {
					self.DeleteLessUsed();
					self.UpdateCache(pathTemplate, buffer, bufferSize);
				}
				// inscrit le nouveau template dans le cache
				else {
					self.AddToCache (pathTemplate, buffer, bufferSize);
				}
			});
		}
		else {
			this.AddToCache (pathTemplate, buffer, bufferSize);
		}
	},
	
	// supprime l'élément le moins utilisé et le plus ancien
	DeleteLessUsed : function() {
		var nbMinUse = this.cache.tpl[0].use,
			iterationFound = 0,
			templates = this.cache.tpl;
		for(var template in templates) {
			if (!templates[template].use) {
				// bah caca, c'est pas beau
				continue;
			}
			if (templates[template].use < templates[iterationFound].use) {
				nbMinUse = templates[template].use;
				iterationFound = template;
			}
		}
		this.cache.size -= templates[iterationFound].file.size;
		templates[iterationFound].content = "";
	},
	
	// TODO penser à appeler CloseTemplateSystem à la fin de vie du serveur
	CloseTemplateSystem : function() {
		var templates = this.cache.tpl;
		for(var template in templates) {
			fs.close(templates[template].file.pt);
		}
		fs.rmdir (this.dossierCacheROM);
	}
}

module.exports = TemplateSystem;
